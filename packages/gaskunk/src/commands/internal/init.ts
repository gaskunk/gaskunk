import { guide, output } from '../../messages';
import path from 'path';
import { promises as fsPromises } from 'fs';
import execa from 'execa';
import { getInstallCmd } from '../../helpers';

const createDirs = async (
  projectRoot: string,
  srcDirName: string,
  publishDirName: string
) => {
  await fsPromises.mkdir(projectRoot, { recursive: true });
  await fsPromises.mkdir(path.join(projectRoot, srcDirName), {
    recursive: true,
  });
  await fsPromises.mkdir(path.join(projectRoot, publishDirName), {
    recursive: true,
  });
};

const createClaspApp = async (
  projectRoot: string,
  publishDirName: string,
  projectName: string
) => {
  output.info(`create ${projectName} with gaskunk...`, '🏠');
  process.chdir(projectRoot);

  await execa('npx', ['clasp', 'create', '--type', 'sheet']);

  const appsScriptJson = await fsPromises.readFile(
    path.join(projectRoot, 'appsscript.json')
  );
  await fsPromises.writeFile(
    path.join(projectRoot, `${publishDirName}/appsscript.json`),
    appsScriptJson
  );
  await fsPromises.unlink(path.join(projectRoot, 'appsscript.json'));

  const claspJsonFile = await fsPromises.readFile(
    path.join(projectRoot, '.clasp.json')
  );
  const claspJson = JSON.parse(claspJsonFile.toString());
  const newClaspJson = {
    ...claspJson,
    rootDir: `./${publishDirName}`,
  };
  await fsPromises.writeFile(
    path.join(projectRoot, '.clasp.json'),
    JSON.stringify(newClaspJson)
  );

  output.success(`created ${projectName}`);
};

const initialize = async (projectRoot: string) => {
  output.info('initializing...', '🔧');
  process.chdir(projectRoot);
  const installCmd = getInstallCmd();

  await execa(installCmd, ['init', '-y']);
  const packageJsonStr = await (
    await fsPromises.readFile(path.join(projectRoot, 'package.json'))
  ).toString();
  const packageJson = JSON.parse(packageJsonStr);
  const scripts = {
    build: 'webpack',
    deploy: 'clasp push',
    open: 'clasp open',
    typecheck: 'tsc --noEmit',
  };
  const newPackageJson = {
    ...packageJson,
    scripts,
  };
  await fsPromises.writeFile(
    path.join(projectRoot, 'package.json'),
    JSON.stringify(newPackageJson, undefined, 2)
  );

  const deps = [
    '@gaskunk/core',
    '@google/clasp',
    '@types/google-apps-script',
    'ts-loader',
    'gas-webpack-plugin',
    'typescript',
    'webpack',
    'webpack-cli',
  ];

  const useYarn = installCmd === 'yarn';
  const installDepsCmd = useYarn ? 'add' : 'install';
  await execa(installCmd, [installDepsCmd, 'install', '-D', ...deps]);
  output.success('initialized');
};

const createConfigFiles = async (
  projectRoot: string,
  srcDirName: string,
  publishDirName: string
) => {
  output.info('create config files...', '🖌️');
  const gitignore = `### https://raw.github.com/github/gitignore/85bf08b19a77c62d7b6286c2db8811f2ff373b0f/Node.gitignore

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# For gaskunk
.clasp.json
`;

  const tsconfigJson = {
    compilerOptions: {
      module: 'commonjs',
      target: 'ES5',
      lib: ['dom', 'esnext', 'dom.iterable'],
      strict: true,
      esModuleInterop: true,
      allowSyntheticDefaultImports: true,
    },
  };

  const webpackConfig = `const path = require('path');
const GasPlugin = require('gas-webpack-plugin');

const SRC_PATH = path.resolve(__dirname, './${srcDirName}');
const DIST_PATH = path.resolve(__dirname, './${publishDirName}');

module.exports = {
  mode: 'production',
  entry: {
    index: SRC_PATH + '/index.ts',
  },
  output: {
    path: DIST_PATH,
    filename: 'index.js',
  },
  module: {
    rules: [
      {
        test: /\.ts$/,
        loader: 'ts-loader',
      },
    ],
  },
  resolve: {
    extensions: ['.ts', '.js'],
  },
  plugins: [new GasPlugin()],
};
`;

  await fsPromises.writeFile(
    path.resolve(projectRoot, '.gitignore'),
    gitignore
  );
  await fsPromises.writeFile(
    path.resolve(projectRoot, 'tsconfig.json'),
    JSON.stringify(tsconfigJson, undefined, 2)
  );
  await fsPromises.writeFile(
    path.resolve(projectRoot, 'webpack.config.js'),
    webpackConfig
  );

  output.success('created config files');
};

const createSampleFiles = async (projectRoot: string, srcDirName: string) => {
  output.info('create sample files...', '🌟');

  const indexTs = `import { doGet } from './events';

declare const global: {
  [key: string]: unknown;
};

global.doGet = doGet;
`;

  const eventsTs = `import { gaskunk } from '@gaskunk/core';

interface DoGetEvents extends GoogleAppsScript.Events.DoGet {
  parameter: {
    action?: string;
  };
}

interface Skunk {
  name: string;
  description: string;
}

interface CreateOutputArgs<T = {}> {
  message: string;
  data?: T;
}

const skunk = gaskunk<Skunk>({ client: 'spreadsheet' });

const createOutput = <T extends object>(args: CreateOutputArgs<T>) => {
  const { message, data } = args;
  return ContentService.createTextOutput(
    JSON.stringify({ status: 200, message: message, data: data })
  ).setMimeType(ContentService.MimeType.JSON);
};

export function doGet(e: DoGetEvents) {
  if (e.parameter.action === 'skunk') {
    const one = SpreadsheetApp.getActive()
      .getSheets()[0]
      .getRange(1, 1)
      .getValues();

    const all = SpreadsheetApp.getActive()
      .getSheetByName('Skunk')
      ?.getDataRange()
      .getValues();

    const names = skunk('Skunk')?.select('name').build();

    const data = {
      one,
      all,
      names: names,
    };
    return createOutput({ message: 'Skunk values', data });
  }
}
`;

  await fsPromises.writeFile(
    path.join(projectRoot, `${srcDirName}/index.ts`),
    indexTs
  );
  await fsPromises.writeFile(
    path.join(projectRoot, `${srcDirName}/index.ts`),
    eventsTs
  );

  output.success('created sample files');
};

export const init = async (
  projectName: string,
  srcDirName: string,
  publishDirName: string
) => {
  const projectRoot = path.resolve(projectName);
  const installCmd = getInstallCmd();

  await createDirs(projectRoot, srcDirName, publishDirName);
  await createClaspApp(projectRoot, publishDirName, projectName);
  await initialize(projectRoot);
  await createConfigFiles(projectRoot, srcDirName, publishDirName);
  await createSampleFiles(projectRoot, srcDirName);

  guide(installCmd, projectName);
};
